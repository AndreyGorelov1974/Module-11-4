/*Задание 4. Оценка результатов игры в крестики-нолики
Что нужно сделать
Петя и Вася играли в крестики-нолики и не стёрли результаты своей игры. Теперь перед вами табличка 3 × 3, которая осталась после их поединка.
Вы хотите понять, выиграл ли кто-то из них или они не доиграли.
На вход программе даётся три строки, кодирующие верхнюю, среднюю и нижнюю строчки игрового поля.
Крестик обозначается символом X (английская заглавная буква X), нолик — символом O (заглавная английская буква O), пустая клетка — точкой.
Если ввод некорректен, то есть такая таблица не могла получиться в ходе настоящей игры, то надо написать в ответ слово Incorrect.
Если таблица корректна и выиграли крестики, то нужно вывести в ответ слова Petya won, если нолики — Vanya won, иначе (то есть они не доиграли или сыграли вничью) надо написать Nobody.

Примеры

X.. 
OXO 
OOO 
Ответ: Incorrect (потому что ноликов в конце игры не может быть больше, чем крестиков).

X.. 
.X. 
OO. 
Ответ: Nobody (потому что они не доиграли).

XXO 
OOX 
XOX 
Ответ: Nobody (потому что это ничья).

XO. 
XO. 
X.O 
Ответ: Incorrect (крестики уже победили, и ноликов не может быть столько же).

OX. 
XOX 
X.O 
Ответ: Incorrect (потому что нолики выиграли за три хода, и на поле за это время не могло успеть появиться четыре крестика).

..X 
OX. 
X.O 
Ответ: Petya won.

0.. 
... 
... 
Ответ: Incorrect (потому что допускаются только символы X, O и точка, а цифра 0 не является допустимым символом).

Рекомендации
Активно используйте оператор индексации строки str[i], но помните, что индексы начинаются с нуля, а не с единицы.
Чтобы обращаться к элементам игрового поля, стоит написать отдельную функцию получения элемента поля по его координатам (x, y). В таком случае часть алгоритмов поиска победителя можно обобщить.
Функции проверки поля на корректность можно отделить от функций и алгоритмов проверки победителя.
При достаточной модульности функций некоторые операции можно реализовать через уже существующие процедуры.
К примеру, если уже есть проверка победителя в строке и имеется функция получения колонки по индексу, то функцию поиска победителя в колонке можно реализовать через обе процедуры.
Проход по диагонали поля можно осуществить в цикле, используя счётчик цикла в качестве обоих координат элемента. Для второй диагонали нужно обратить одну из координат (2 − x или 2 − y).
Общие условия некорректности поля таковы:
выявлено несколько победителей одновременно;
нолики победили, а крестиков больше, чем ноликов;
крестики победили, а ноликов столько же или больше;
нолики и крестики победили несколько раз;
на поле есть невалидные символы.
Для упрощения лучше создать отдельные функции для проверки победителя в строке или столбце, которые на вход принимают строку, а на выходе выдают символ победителя. То есть ‘X’, ‘O’ или ‘.’*/

#include <iostream>
#include <string>

// функция ввода входных данных
std::string enter_line (int n) {
	std::string str;
	std::cout << "Enter the line number " << n << ": ";
	std::cin >> str;
	while (str.length() != 3) {
		std::cout << "The length of the string must be 3 characters. Enter again: ";
		std::cin >> str;
	}
	return str;
}

//фунция получения символа по его координатам
char get_symbol_by_coordinates(std::string line1, std::string line2, std::string line3, int x, int y) {
	x--;
	if (y == 1) {
		return line1[x];
	}
	if (y == 2) {
		return line2[x];
	}
	if (y == 3) {
		return line3[x];
	}
}

//функция проверки игрового поля
bool checking_playing_field(std::string line1, std::string line2, std::string line3) {



	return false;
}

//функция определения победителя
void who_won(std::string line1, std::string line2, std::string line3) {
	
	std::cout << "won.";
	return;
}

int main() {

	std::string firstLine = enter_line(1);
	std::string secondLine = enter_line(2);
	std::string thirdLine = enter_line(3);

	if (checking_playing_field (firstLine, secondLine, thirdLine)) {
		who_won (firstLine, secondLine, thirdLine);
	}
	else {
		std::cout << "Incorrect.";
	}

	std::cout << std::endl << get_symbol_by_coordinates(firstLine, secondLine, thirdLine, 3, 3);


}